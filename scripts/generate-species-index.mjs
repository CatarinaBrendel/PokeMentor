// scripts/generate-species-index.mjs
import fs from "node:fs";
import path from "node:path";
import process from "node:process";

const ROOT = process.cwd();

const SPRITES_DIR = path.join(ROOT, "public", "sprites", "pokemon");
const OUT_FILE = path.join(ROOT, "src", "features", "pokemon", "speciesIndex.ts");

// Tune concurrency if needed (PokéAPI is friendly but don't hammer it)
const CONCURRENCY = 8;

// Basic concurrency runner
async function runPool(items, worker, concurrency) {
  const results = new Array(items.length);
  let nextIndex = 0;

  async function runOne() {
    while (true) {
      const i = nextIndex++;
      if (i >= items.length) return;
      results[i] = await worker(items[i], i);
    }
  }

  await Promise.all(Array.from({ length: concurrency }, () => runOne()));
  return results;
}

function listDexIdsFromFilenames(dir) {
  if (!fs.existsSync(dir)) {
    throw new Error(
      `Sprites directory not found: ${dir}\n` +
        `Expected: public/sprites/pokemon/<dexId>.png`
    );
  }

  const files = fs.readdirSync(dir);
  const ids = [];

  for (const f of files) {
    const m = /^(\d+)\.png$/i.exec(f);
    if (!m) continue;

    const id = Number(m[1]);

    // 0.png is your local "unknown" sprite – keep it in assets, but don't map it via PokéAPI.
    if (!Number.isFinite(id) || id <= 0) continue;

    ids.push(id);
  }
    // Unique + sorted
  return Array.from(new Set(ids)).sort((a, b) => a - b);
}

async function fetchPokemonNameById(id) {
  const url = `https://pokeapi.co/api/v2/pokemon/${id}`;

  const res = await fetch(url, {
    headers: { "User-Agent": "pokementor-dev-script/1.0" },
  });

  if (!res.ok) {
    throw new Error(`PokéAPI request failed for id=${id}: ${res.status} ${res.statusText}`);
  }

  const json = await res.json();

  // PokéAPI "name" is already slugified (e.g. "flutter-mane")
  if (!json?.name || typeof json.name !== "string") {
    throw new Error(`Unexpected PokéAPI payload for id=${id} (missing name)`);
  }

  return json.name;
}

function ensureOutDir(filePath) {
  const dir = path.dirname(filePath);
  fs.mkdirSync(dir, { recursive: true });
}

function writeSpeciesIndexTs(outFile, entries) {
  // entries: Array<{ slug: string; id: number }>
  const lines = [];
  lines.push("// AUTO-GENERATED FILE. DO NOT EDIT.");
  lines.push("// Generated by: scripts/generate-species-index.mjs");
  lines.push(`// Generated at: ${new Date().toISOString()}`);
  lines.push("");
  lines.push("export const SPECIES_TO_DEX_ID: Record<string, number> = {");

  // stable ordering by slug
  entries
    .slice()
    .sort((a, b) => a.slug.localeCompare(b.slug))
    .forEach(({ slug, id }) => {
      lines.push(`  "${slug}": ${id},`);
    });

  lines.push("};");
  lines.push("");

  ensureOutDir(outFile);
  fs.writeFileSync(outFile, lines.join("\n"), "utf8");
}

async function main() {
  console.log(`Reading sprites from: ${SPRITES_DIR}`);
  const ids = listDexIdsFromFilenames(SPRITES_DIR);

  if (ids.length === 0) {
    console.log("No numeric sprite files found. Expected files like 445.png");
    process.exit(1);
  }

  console.log(`Found ${ids.length} sprite IDs.`);
  console.log(`Fetching PokéAPI (concurrency=${CONCURRENCY})...`);

  const entries = await runPool(
    ids,
    async (id) => {
      const name = await fetchPokemonNameById(id);
      return { slug: name, id };
    },
    CONCURRENCY
  );

  // Detect collisions (rare but possible with forms/duplicates)
  const slugToId = new Map();
  const collisions = [];
  for (const e of entries) {
    const prev = slugToId.get(e.slug);
    if (prev != null && prev !== e.id) {
      collisions.push({ slug: e.slug, a: prev, b: e.id });
    } else {
      slugToId.set(e.slug, e.id);
    }
  }

  if (collisions.length) {
    console.warn("WARNING: slug collisions detected (forms/duplicates):");
    for (const c of collisions.slice(0, 20)) {
      console.warn(`  ${c.slug}: ${c.a} vs ${c.b}`);
    }
    console.warn("Keeping the first occurrence. Consider adding form keys later.");
  }

  const uniqueEntries = Array.from(slugToId.entries()).map(([slug, id]) => ({ slug, id }));

  console.log(`Writing: ${OUT_FILE}`);
  writeSpeciesIndexTs(OUT_FILE, uniqueEntries);

  console.log(`Done. Wrote ${uniqueEntries.length} entries.`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});